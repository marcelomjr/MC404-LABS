// 'gpio.cpp' - GPIO model
//
// Copyright (C) 2014 The ArchC team.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// ----------------------------------------------------------------------
// This represents the UART used in the ARM SoC by Freescale iMX35.
//
// Author : George Gondim Ribeiro, 03/10/2014
//
// ----------------------------------------------------------------------

#include "gpio.h"
#include "arm_interrupts.h"

extern bool DEBUG_GPIO;

#include <stdarg.h>

static inline int
dprintf(const char *format, ...)
{
    int ret;

    if (DEBUG_GPIO)
    {
        va_list args;
        va_start (args, format);
        ret = vfprintf(ac_err, format, args);
        va_end (args);
    }
    return ret;
}

unsigned
gpio_module::fast_read(unsigned address)
{
    unsigned res = 0;
    switch (address)
    {
    case GPIO_DR:
        return (*(regs + GPIO_DR / 4) & *(regs + GPIO_DIR / 4)) |
            (*(regs + GPIO_PSR / 4) & ~*(regs + GPIO_DIR / 4)); 
    default:
        return *(regs + address / 4);
    }
    return res;
}

void
gpio_module::fast_write(unsigned address, unsigned datum)
{
    switch (address)
    {
        // Read-only registers
    case GPIO_PSR:
        break;
        
        // Write allowed registers
    case GPIO_DR:
    case GPIO_DIR:              
    case GPIO_ICR1:
    case GPIO_ICR2:
    case GPIO_IMR:
    case GPIO_ISR:
    case GPIO_EDGE_SEL:
        *(regs + address / 4) = datum;
        break;
        
    default:
        break;
    }
}



unsigned 
gpio_module::read_signal (unsigned address, unsigned offset)
{
    return fast_read (address);
}



void 
gpio_module::write_signal (unsigned address, unsigned datum, 
                           unsigned offset)
{
    fast_write (address, datum);
}





void 
gpio_module::prc_gpio ()
{
    do
    {
        wait (1, SC_NS);

        if (!enabled)
            continue;

        if (clock_src == CLK_OFF | clock_src == EXTERNAL_CLK)
            continue;

        dprintf ("-------------------- GPIO --------------------- \n");
        dprintf ("Data register: 0x%X\n", *(regs + GPIO_DR / 4));
        dprintf ("Direction register: 0x%X\n", *(regs + GPIO_DIR / 4));
        dprintf ("Pad status register:: 0x%X\n", *(regs + GPIO_PSR / 4));

        // Verify changes in GPIO's input (GPIO_PSR)
        // Adicionar comunicação aqui:
        // Ler bits de entrada e escrever bits de saída no mecanismo de comunicao
        // GPIO_DIR guarda se um bit é de saída ou entrada.
        // GPIO_DR armazena dados de saída dos pinos
        // GPIO_PSR indica os bits de entrada
	  
        // Generate interrupts
        // gpio_irqnum_t gpio_irq_num;
        int gpio_irq_num;
        unsigned mask_icr = 0x3, mask_imr = 0x1;
      
        for (gpio_irq_num = GPIO_INT0; gpio_irq_num < GPIO_INT16_31; gpio_irq_num++) {
            if ((*(regs + GPIO_ICR1 / 4) & mask_icr) && (*(regs + GPIO_IMR/4) & mask_imr))  {
                tzic.interrupt (gpio_irq_num, false);
                dprintf("Asserted interrupt line in TZIC. IRQNUM %d\n", gpio_irq_num);
            }
            else
                tzic.interrupt (gpio_irq_num, true);
            mask_icr << 2;
            mask_imr << 1;
        }
		
    } while (1);
}
